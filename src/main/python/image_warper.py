# -*- coding: utf-8 -*-
"""Project 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZmD3wobKQxDjKR5ia_kp5dcDgTyP2ESW
"""

# Name: Andrew Valentin
# Class: CAP4453 (Robot Vision)
# Semester: Spring 2023
# UCF ID: 5388715

# Import libraries
from skimage import io

import cv2
import math
import matplotlib.pyplot as plt
import numpy as np
import sys

### Functions ###

# Created the rows that are used in computing the homography matrix
def addPointRows(pts, pts_prime):
  img_pts = np.empty((0, 8))

  for i in range(len(pts)):
    img_pts = np.vstack((img_pts, [pts[i][0], pts[i][1], 1, 0, 0, 0, -1 * pts[i][0] * pts_prime[i][0], -1 * pts[i][1] * pts_prime[i][0]]))
    img_pts = np.vstack((img_pts, [0, 0, 0, pts[i][0], pts[i][1], 1, -1 * pts[i][0] * pts_prime[i][1], -1 * pts[i][1] * pts_prime[i][1]]))

  return img_pts

# Computes and returns homography matrix
def computeH(img1_pts, img2_pts):
  img1_pts = addPointRows(img1_pts, img2_pts)
  img2_pts = img2_pts.reshape((int(len(img2_pts) * 2), 1))

  img1_transposed = np.transpose(img1_pts)
  term1 = np.linalg.inv(np.matmul(img1_transposed, img1_pts))
  term2 = np.matmul(img1_transposed, img2_pts)
  H = np.matmul(term1, term2)

  H = np.vstack((H, 1.))
  H = H.reshape(3, 3)

  return H

# Plots points and cluster centers
def plot_clusters(centers, cornervals, clusters, k):
    print('Circle = Point')
    print('Square = Center of cluster')

    print('Centers:')
    for i in range(k):
      print('    ', centers[i])

    colors = ['red', 'green', 'blue', 'purple']

    plt.scatter(cornervals[:, 0], cornervals[:, 1])

    for i in range(len(clusters)):
      print(i)
      plt.scatter(centers[i][0], centers[i][1], c=colors[i], marker='s')

    plt.xlabel('Width')
    plt.ylabel('Height')
    plt.show()

# perform k-means grouping to find a point for each edge
def mean(cluster, x=0, y= 0):
  sum = 0;

  for point in cluster:
    if x == 1:
      sum += point[1]
    elif y == 1:
      sum += point[2]

  return sum / len(cluster)

'''
def recalc_centers(prev_centers, clusters, k):
  change = 0
  centers = []

  for i in range(k):
    centers.append([])

  for i in range(k):
    prev_center = []
    prev_center.append(prev_centers[i][0])
    prev_center.append(prev_centers[i][1])

    centers[i].append(mean(clusters[i], x=1))
    centers[i].append(mean(clusters[i], y=1))

    if prev_center[0] != centers[i][0] or prev_center[1] != centers[i][1]:
      change = 1

  return centers, change
'''

def recalc_centers(prev_centers, clusters, k):
  centers = []

  for i in range(k):
    centers.append([])

  for i in range(k):
    prev_center = []
    prev_center.append(prev_centers[i][0])
    prev_center.append(prev_centers[i][1])

    centers[i].append(mean(clusters[i], x=1))
    centers[i].append(mean(clusters[i], y=1))

  return centers

def filter_clusters(clusters, k):
  groups = []

  for i in range(k):
    groups.append([])

  for cluster in clusters:
    groups[cluster[0]].append(cluster)

  return groups

# d_ij = |Age_i - Age_j| + m|Height_i - Height_j|

def find_dist(center, point, m):
  return math.fabs(center[0] - point[0]) + m * math.fabs(center[1] - point[1])

def cluster_vals(centers, corners, k, m):
  groups = []

  # loop through info
  for point in corners:
    # assign groups
    index = 0
    dist = []
    group = []
    point_list = [point[0], point[1]]

    for i in range(k):
      dist.append(find_dist(centers[i], point_list, m))

    for i in range(k):
      if dist[i] < dist[index]:
        index = i

    group.append(index)
    groups.append(group + point_list)

  groups = filter_clusters(groups, k)

  return groups

'''
def emptyGroup(groups):
  for group in groups:
    if len(group) == 0: return 1
  return 0


def cluster(seeds, corners, k=1, m = 10):
  change = 1
  centers, groups = seeds, []

  print('num points: ', len(corners))

  while change == 1:
    groups = cluster_vals(centers, corners, k, m)

    if emptyGroup(groups):
      print('new cluster')
      return cluster(seeds, corners, k, m + 10)

    centers, change = recalc_centers(centers, groups, k)
    plot_clusters(centers, groups, k)

    return centers, groups

  return centers, groups
'''

def cluster(seeds, corners, k=1, m = 10):
  groups = []

  groups = cluster_vals(seeds, corners, k, m)
  centers = recalc_centers(seeds, groups, k)

  return centers, groups

# Returns a list that contains all of the corner points detected in an image
def findCorners(img):
  corners = np.array([])

  h, w = img.shape

  for i in range(h):
    for j in range(w):
      if img[i][j] == 150:
        if len(corners) == 0:
          corners = np.append(corners, [i, j])
        else:
          corners = np.vstack((corners, [i, j]))

  return corners

# Returns a gaussian kernel
def gauskern(klen=5, sig=1.0):
  # returns n equally spaced values between [start] and [end]
  gaus = np.linspace(-(klen - 1) / 2, (klen - 1) / 2, klen)

  # returns an 2 2d arrays (with the height y and length x):
  # - one for the x values
  # - one for the y values
  x, y = np.meshgrid(gaus, gaus)

  # returns an array of e^x for all x in the array (the argument)
  kernel = np.exp((np.square(x) + np.square(y)) / (-2 * np.square(sig)))

  # return a normalized version of the filter
  return kernel / np.sum(kernel)

# Blurs an image and returns blurred image
def blurImage(img):
  # perform median box filter to smooth edges
  img = cv2.medianBlur(img, 49)

  # perform gaussian filter to smooth edges even further
  img = cv2.filter2D(src=img, ddepth=-1, kernel=gauskern(20, 100))
  img[img > 255] = 255
  img[img < 0] = 0

  # perform median box filter to smooth edges
  img = cv2.medianBlur(img, 49)

  # perform gaussian filter to smooth edges even further
  img = cv2.filter2D(src=img, ddepth=-1, kernel=gauskern(50, 100))
  img[img > 255] = 255
  img[img < 0] = 0

  return img

# Get the edges of the image for warping
def getEdges(img):
  # Convert to blue channel only in order to get better color contrast
  blue_img = np.array(img)
  blue_img[:, :, 0] = 0
  blue_img[:, :, 1] = 0

  img2 = blurImage(blue_img)

  # threshold image to isolate the main parts of the image
  ret, img2 = cv2.threshold(img2[:, :, 2], 0, 255, cv2.THRESH_OTSU)

  # apply lapace function to isolate edges
  img2 = cv2.Laplacian(img2, -1, ksize=5)

  return img2

def rectifyImage(filePath):
  # Read in and print image
  img = io.imread(filePath)

  height, width, colors = img.shape

  img2 = getEdges(img)

  # Use Harris corner detection to find corners
  corners = cv2.cornerHarris(img2, 40, 7, 0.05)
  corners = cv2.dilate(corners, None)

  # Highlight corners by giving them a unique value
  img2[corners > 0.01 * corners.max()] = 150

  cornervals = findCorners(img2)

  # Perform K-means clustering
  k = 4

  seeds = [[0, 0],
          [height, 0],
          [height, width],
          [0, width]]

  centers, clusters = cluster(seeds, cornervals, k)
  #plot_clusters(centers, cornervals, clusters, k)

  """find homagraphy matrix"""

  # Image points are written as [column, row]
  img1_pts = np.array([[centers[0][1], centers[0][0]],   #tl
                      [centers[1][1], centers[1][0]],   #bl
                      [centers[2][1], centers[2][0]],   #br
                      [centers[3][1], centers[3][0]]])  #tr

  '''
  img1_pts = np.array([[300, 500],   #tl
                      [250, 1100],   #bl
                      [950, 1050],   #br
                      [900, 400]])  #tr
  '''

  img2_pts = np.array([[0, 0],           #tl
                      [0, height],      #bl
                      [width, height],  #br
                      [width, 0]])      #tr

  # Find the homography matrix
  H = computeH(img1_pts, img2_pts)

  # Warp the image using the homography matrix
  warped_img = cv2.warpPerspective(img, H, (width, height))

  return warped_img

img = rectifyImage(sys.argv[1])

print(img.shape[1])
print(img.shape[0])

#plt.imshow(img)
#plt.show()

for row in img:
  for pixel in row:
    print((pixel[0] << 16) | (pixel[1] << 8) | pixel[2])